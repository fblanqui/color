(**
CoLoR, a Coq library on rewriting and termination.
See the COPYRIGHTS and LICENSE files.

- Sebastien Hinderer, 2004-02-09
- Frederic Blanqui, 2005-02-17

algebraic terms with fixed arity
*)

(* $Id: ATerm.v,v 1.11 2008-01-23 09:27:49 blanqui Exp $ *)

Set Implicit Arguments.

Require Export ASignature.
Require Export ListUtil.
Require Export LogicUtil.

Notation variables := (list variable).

Section S.

Variable Sig : Signature.

(***********************************************************************)
(** terms *)

Require Export VecUtil.

Inductive term : Set :=
  | Var : variable -> term
  | Fun : forall f : Sig, vector term (arity f) -> term.

(* we delete the induction principle generated by coq since it is not good
because the argument of Fun is a vector *)

Reset term_rect.

Notation terms := (vector term).

Notation "'args' f" := (terms (arity f)) (at level 70).

(***********************************************************************)
(** induction principles *)

Section term_rect.

Variables
  (P : term -> Type)
  (Q : forall n, terms n -> Type).

Hypotheses
  (H1 : forall x, P (Var x))
  (H2 : forall f (v : args f), Q v -> P (Fun f v))
  (H3 : Q Vnil)
  (H4 : forall t n (v : terms n), P t -> Q v -> Q (Vcons t v)).

Fixpoint term_rect t : P t :=
  match t as t return P t with
    | Var x => H1 x
    | Fun f v =>
      let fix terms_rect n (v : terms n) {struct v} : Q v :=
        match v as v return Q v with
          | Vnil => H3
          | Vcons t' n' v' => H4 (term_rect t') (terms_rect n' v')
        end
	in H2 f (terms_rect (arity f) v)
  end.

End term_rect.

Definition term_ind (P : term -> Prop) (Q : forall n, terms n -> Prop) :=
  term_rect P Q.

Definition term_rec (P : term -> Set) (Q : forall n, terms n -> Set) :=
  term_rect P Q.

Lemma term_ind_forall : forall (P : term -> Prop)
  (H1 : forall v, P (Var v))
  (H2 : forall f (v : args f), Vforall P v -> P (Fun f v)),
  forall t, P t.

Proof.
intros. apply term_ind with (Q := Vforall P). assumption. assumption.
exact I. intros. simpl. split; assumption.
Qed.

(***********************************************************************)
(** equality *)

Lemma var_eq : forall x x', x = x' -> Var x = Var x'.

Proof.
intros. rewrite H. refl.
Qed.

Lemma args_eq : forall f (v v' : args f), v = v' -> Fun f v = Fun f v'.

Proof.
intros. rewrite H. refl.
Qed.

(***********************************************************************)
(** decidability of equality *)

Lemma eq_term_dec : forall t u : term, {t=u}+{~t=u}.

Proof.
intro. pattern t. apply term_rec with
  (Q := fun n (ts : terms n) => forall u, {ts=u}+{~ts=u}); clear t.
(* var *)
intros. destruct u. case (eq_nat_dec x n); intro. subst n. auto.
right. unfold not. intro. injection H. auto.
right. unfold not. intro. discriminate.
(* fun *)
intros f ts H u. destruct u. right. unfold not. intro. discriminate.
case (eq_symbol_dec f f0); intro. subst f0. case (H v); intro. subst ts. auto.
right. intro. injection H0. intro. assert (ts=v).
Require Import Eqdep. apply (inj_pair2 Sig (fun f => args f)). assumption. auto.
right. unfold not. intro. injection H0. intros. auto.
(* nil *)
intro. VOtac. auto.
(* cons *)
intros. VSntac u. case (H (Vhead u)); intro. rewrite e.
case (H0 (Vtail u)); intro. rewrite e0. auto.
right. unfold not. intro. injection H2. intro. assert (v = Vtail u).
apply (inj_pair2 nat (fun n => terms n)). assumption. auto.
right. unfold not. intro. injection H2. intros. auto.
Defined.

(***********************************************************************)
(** maximal variable index in a term *)

Require Export VecMax.

Fixpoint maxvar (t : term) : nat :=
  match t with
    | Var x => x
    | Fun f v =>
      let fix maxvars (n : nat) (v : terms n) {struct v} : nats n :=
        match v in vector _ n return nats n with
          | Vnil => Vnil
          | Vcons t' n' v' => Vcons (maxvar t') (maxvars n' v')
        end
      in Vmax (maxvars (arity f) v)
  end.

Lemma maxvar_fun : forall f ts, maxvar (Fun f ts) = Vmax (Vmap maxvar ts).

Proof.
intros. simpl. apply (f_equal (@Vmax (arity f))).
induction ts. auto. rewrite IHts. auto.
Qed.

Lemma maxvar_var : forall k x, maxvar (Var x) <= k -> x <= k.

Proof.
intros. simpl. intuition.
Qed.

Definition maxvar_le k t := maxvar t <= k.

Lemma maxvar_le_fun : forall m f ts,
  maxvar (Fun f ts) <= m -> Vforall (maxvar_le m) ts.

Proof.
intros until ts. rewrite maxvar_fun. intro. generalize (Vmax_forall H).
clear H. intro H. generalize (Vforall_map_elim H). intuition.
Qed.

Lemma maxvar_le_arg : forall f ts m t,
  maxvar (Fun f ts) <= m -> Vin t ts -> maxvar t <= m.

Proof.
intros. assert (Vforall (maxvar_le m) ts). apply maxvar_le_fun. assumption.
change (maxvar_le m t). eapply Vforall_in with (n := arity f). apply H1.
assumption.
Qed.

(***********************************************************************)
(** list of variables in a term:
a variable occurs in the list as much as it has occurrences in t *)

Fixpoint vars (t : term) : variables :=
  match t with
    | Var x => x :: nil
    | Fun f v =>
      let fix vars_vec n (ts : terms n) {struct ts} : variables :=
        match ts with
          | Vnil => nil
          | Vcons t' n' ts' => vars t' ++ vars_vec n' ts'
        end
      in vars_vec (arity f) v
  end.

Fixpoint vars_vec n (ts : terms n) {struct ts} : variables :=
  match ts with
    | Vnil => nil
    | Vcons t' _ ts' => vars t' ++ vars_vec ts'
  end.

Lemma vars_fun : forall f (ts : args f), vars (Fun f ts) = vars_vec ts.

Proof.
auto.
Qed.

Lemma vars_vec_cast : forall n (ts : terms n) m (h : n=m),
  vars_vec (Vcast ts h) = vars_vec ts.

Proof.
induction ts; intros; destruct m; simpl; try (refl || discriminate).
apply (f_equal (fun l => vars a ++ l)). apply IHts.
Qed.

Lemma vars_vec_app : forall n1 (ts1 : terms n1) n2 (ts2 : terms n2),
  vars_vec (Vapp ts1 ts2) = vars_vec ts1 ++ vars_vec ts2.

Proof.
induction ts1; intros; simpl. refl. rewrite app_ass.
apply (f_equal (fun l => vars a ++ l)). apply IHts1.
Qed.

Lemma vars_vec_cons : forall t n (ts : terms n),
  vars_vec (Vcons t ts) = vars t ++ vars_vec ts.

Proof.
intros. refl.
Qed.

Lemma in_vars_vec_elim : forall x n (ts : terms n),
  In x (vars_vec ts) -> exists t, Vin t ts /\ In x (vars t).

Proof.
induction ts; simpl; intros. contradiction. generalize (in_app_or H). intro.
destruct H0. exists a. intuition. generalize (IHts H0). intro.
destruct H1 as [t].
exists t. intuition.
Qed.

Lemma in_vars_vec_intro : forall x t n (ts : terms n),
  In x (vars t) -> Vin t ts -> In x (vars_vec ts).

Proof.
intros. deduce (Vin_elim H0). do 5 destruct H1. subst ts.
rewrite vars_vec_cast. rewrite vars_vec_app. simpl.
apply in_appr. apply in_appl. exact H.
Qed.

Require Export ListUtil.

Lemma vars_vec_in : forall x t n (ts : terms n),
  In x (vars t) -> Vin t ts -> In x (vars_vec ts).

Proof.
induction ts; simpl; intros. contradiction. destruct H0. subst t.
apply in_appl. assumption. apply in_appr. apply IHts; assumption.
Qed.

Lemma vars_max : forall x t, In x (vars t) -> x <= maxvar t.

Proof.
intro.
set (Q := fun n (ts : terms n) =>
  In x (vars_vec ts) -> x <= Vmax (Vmap maxvar ts)).
intro. pattern t. apply term_ind with (Q := Q); clear t; unfold Q; simpl; intros.
intuition. apply H. assumption. contradiction. generalize (in_app_or H1).
intro. destruct H2. apply elim_max_l. apply H. assumption.
apply elim_max_r. apply H0. assumption.
Qed.

Lemma maxvar_in : forall x t n (v : terms n),
  x <= maxvar t -> Vin t v -> x <= Vmax (Vmap maxvar v).

Proof.
induction v; simpl; intros. contradiction. destruct H0. subst t.
apply elim_max_l. assumption. apply elim_max_r. apply IHv; assumption.
Qed.

Require Export ListMax.

Lemma maxvar_lmax : forall t, maxvar t = lmax (vars t).

Proof.
intro t. pattern t.
set (Q := fun n (ts : terms n) => Vmax (Vmap maxvar ts) = lmax (vars_vec ts)).
apply term_ind with (Q := Q); clear t.
intro. simpl. apply (sym_equal (max_l (le_O_n x))).
intros f ts H. rewrite maxvar_fun. rewrite vars_fun. assumption.
unfold Q. auto.
intros t n ts H1 H2. unfold Q. simpl. rewrite lmax_app.
unfold Q in H2. rewrite H1. rewrite H2. refl.
Qed.

(***********************************************************************)
(** number of distinct variables in a term *)

Require Export ListRepeatFree.

Definition nb_distinct_vars t :=
  length (make_repeat_free eq_nat_dec (vars t)).

(***********************************************************************)
(** number of symbol occurrences in a term *)

Fixpoint nb_symbols t :=
  match t with
    | Var x => 0
    | Fun f ts =>
      let fix nb_symbols_terms n (ts : terms n) {struct ts} :=
        match ts with
          | Vnil => 0
          | Vcons u p us => nb_symbols u + nb_symbols_terms p us
        end
        in nb_symbols_terms _ ts
  end.

End S.

(***********************************************************************)
(** implicit arguments *)

Implicit Arguments Var [Sig].
Implicit Arguments maxvar_var [Sig k x].
Implicit Arguments maxvar_le_fun [Sig m f ts].
Implicit Arguments maxvar_le_arg [Sig f ts m t].
Implicit Arguments in_vars_vec_elim [Sig x n ts].
Implicit Arguments in_vars_vec_intro [Sig x t n ts].
Implicit Arguments vars_vec_in [Sig x t n ts].
Implicit Arguments vars_max [Sig x t].

(***********************************************************************)
(** tactics *)

Ltac Funeqtac := repeat
  match goal with
    | H : @Fun ?Sig ?f ?ts = Fun ?f ?us |- _ =>
      let H1 := fresh in let H2 := fresh in
      (injection H; intro H1; assert (H2 : ts = us);
      [apply (inj_pair2 Sig (fun h => @vector (@term Sig) (arity h))); assumption
      | clear H H1])
    | H : @Fun ?Sig ?f ?ts = Fun ?g ?us |- _ =>
      injection H; intros _ fresh; subst g; Funeqtac
  end.
