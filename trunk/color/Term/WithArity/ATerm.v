(**
CoLoR, a Coq library on rewriting and termination.
See the COPYRIGHTS and LICENSE files.

- Sebastien Hinderer, 2004-02-09
- Frederic Blanqui, 2005-02-17

algebraic terms with fixed arity
*)

(* $Id: ATerm.v,v 1.2 2007-01-19 17:22:40 blanqui Exp $ *)

Set Implicit Arguments.

Section S.

Require Export ASignature.

Variable Sig : Signature.

(***********************************************************************)
(** terms *)

Require Export VecUtil.

Inductive term : Set :=
  | Var : variable -> term
  | Fun : forall f : Sig, vector term (arity f) -> term.

(* we delete the induction principle generated by coq since it is not good
because the argument of Fun is a vector *)

Reset term_rect.

Notation terms := (vector term).

Notation "'args' f" := (terms (arity f)) (at level 70).

(***********************************************************************)
(** induction principles *)

Section term_rect.

Variables
  (P : term -> Type)
  (Q : forall n, terms n -> Type).

Hypotheses
  (H1 : forall x, P (Var x))
  (H2 : forall f (v : args f), Q v -> P (Fun f v))
  (H3 : Q Vnil)
  (H4 : forall t n (v : terms n), P t -> Q v -> Q (Vcons t v)).

Fixpoint term_rect t : P t :=
  match t as t return P t with
    | Var x => H1 x
    | Fun f v =>
      let fix terms_rect n (v : terms n) {struct v} : Q v :=
        match v as v return Q v with
          | Vnil => H3
          | Vcons t' n' v' => H4 (term_rect t') (terms_rect n' v')
        end
	in H2 f (terms_rect (arity f) v)
  end.

End term_rect.

Definition term_ind (P : term -> Prop) (Q : forall n, terms n -> Prop) :=
  term_rect P Q.

Definition term_rec (P : term -> Set) (Q : forall n, terms n -> Set) :=
  term_rect P Q.

Lemma term_ind_forall : forall (P : term -> Prop)
  (H1 : forall v, P (Var v))
  (H2 : forall f (v : args f), Vforall P v -> P (Fun f v)),
  forall t, P t.

Proof.
intros. apply term_ind with (Q := Vforall P). assumption. assumption.
exact I. intros. simpl. split; assumption.
Qed.

(***********************************************************************)
(** maximal index of a variable *)

Require Export VecMax.

Fixpoint maxvar (t : term) : nat :=
  match t with
    | Var x => x
    | Fun f v =>
      let fix maxvars (n : nat) (v : terms n) {struct v} : nats n :=
        match v in vector _ n return nats n with
          | Vnil => Vnil
          | Vcons t' n' v' => Vcons (maxvar t') (maxvars n' v')
        end
      in Vmax (maxvars (arity f) v)
  end.

Lemma maxvar_fun : forall f ts, maxvar (Fun f ts) = Vmax (Vmap maxvar ts).

Proof.
intros. simpl. apply (f_equal (@Vmax (arity f))).
induction ts. auto. rewrite IHts. auto.
Qed.

Lemma maxvar_var : forall k x, maxvar (Var x) <= k -> x <= k.

Proof.
intros. simpl. intuition.
Qed.

Definition maxvar_le k t := maxvar t <= k.

Lemma maxvar_le_fun : forall m f ts,
  maxvar (Fun f ts) <= m -> Vforall (maxvar_le m) ts.

Proof.
intros until ts. rewrite maxvar_fun. intro. generalize (Vmax_forall H).
clear H. intro H. generalize (Vforall_map_intro H). intuition.
Qed.

Lemma maxvar_le_arg : forall f ts m t,
  maxvar (Fun f ts) <= m -> Vin t ts -> maxvar t <= m.

Proof.
intros. assert (Vforall (maxvar_le m) ts). apply maxvar_le_fun. assumption.
change (maxvar_le m t). eapply Vforall_in with (n := arity f). apply H1.
assumption.
Qed.

(***********************************************************************)
(** list of variables in a term:
a variable occurs in the list as much as it has occurrences in t *)

Require Export List.

Fixpoint varlist (t : term) : list variable :=
  match t with
    | Var x => x :: nil
    | Fun f v =>
      let fix varlists n (ts : terms n) {struct ts} : list variable :=
        match ts with
          | Vnil => nil
          | Vcons t' n' ts' => varlist t' ++ varlists n' ts'
        end
      in varlists (arity f) v
  end.

Fixpoint varlists n (ts : terms n) {struct ts} : list variable :=
  match ts with
    | Vnil => nil
    | Vcons t' _ ts' => varlist t' ++ varlists ts'
  end.

Lemma varlist_fun : forall f (ts : args f), varlist (Fun f ts) = varlists ts.

Proof.
auto.
Qed.

Lemma varlists_cast : forall n (ts : terms n) m (h : n=m),
  varlists (Vcast ts h) = varlists ts.

Proof.
induction ts; intros; destruct m; simpl; try (reflexivity || discriminate).
apply (f_equal (fun l => varlist a ++ l)). apply IHts.
Qed.

Lemma varlists_app : forall n1 (ts1 : terms n1) n2 (ts2 : terms n2),
  varlists (Vapp ts1 ts2) = varlists ts1 ++ varlists ts2.

Proof.
induction ts1; intros; simpl. reflexivity. rewrite app_ass.
apply (f_equal (fun l => varlist a ++ l)). apply IHts1.
Qed.

Lemma varlists_cons : forall t n (ts : terms n),
  varlists (Vcons t ts) = varlist t ++ varlists ts.

Proof.
intros. reflexivity.
Qed.

Implicit Arguments in_app_or [A l m a].

Lemma in_varlists : forall x n (ts : terms n),
  In x (varlists ts) -> exists t, Vin t ts /\ In x (varlist t).

Proof.
induction ts; simpl; intros. contradiction. generalize (in_app_or H). intro.
destruct H0. exists a. intuition. generalize (IHts H0). intro. destruct H1 as [t].
exists t. intuition.
Qed.

Require Export ListUtil.

Lemma varlists_in : forall x t n (ts : terms n),
  In x (varlist t) -> Vin t ts -> In x (varlists ts).

Proof.
induction ts; simpl; intros. contradiction. destruct H0. subst t.
apply in_appl. assumption. apply in_appr. apply IHts; assumption.
Qed.

Lemma varlist_max : forall x t, In x (varlist t) -> x <= maxvar t.

Proof.
intro.
set (Q := fun n (ts : terms n) => In x (varlists ts) -> x <= Vmax (Vmap maxvar ts)).
intro. pattern t. apply term_ind with (Q := Q); clear t; unfold Q; simpl; intros.
intuition. apply H. assumption. contradiction. generalize (in_app_or H1).
intro. destruct H2. apply elim_max_l. apply H. assumption.
apply elim_max_r. apply H0. assumption.
Qed.

Lemma maxvar_in : forall x t n (v : terms n),
  x <= maxvar t -> Vin t v -> x <= Vmax (Vmap maxvar v).

Proof.
induction v; simpl; intros. contradiction. destruct H0. subst t.
apply elim_max_l. assumption. apply elim_max_r. apply IHv; assumption.
Qed.

Require Export ListMax.

Lemma maxvar_lmax : forall t, maxvar t = lmax (varlist t).

Proof.
intro t. pattern t.
set (Q := fun n (ts : terms n) => Vmax (Vmap maxvar ts) = lmax (varlists ts)).
apply term_ind with (Q := Q); clear t.
intro. simpl. apply (sym_equal (max_l (le_O_n x))).
intros f ts H. rewrite maxvar_fun. rewrite varlist_fun. assumption.
unfold Q. auto.
intros t n ts H1 H2. unfold Q. simpl. rewrite lmax_app.
unfold Q in H2. rewrite H1. rewrite H2. reflexivity.
Qed.

(***********************************************************************)
(** decidability of equality *)

Lemma eq_term_dec : forall t u : term, {t=u}+{~t=u}.

Proof.
intro. pattern t. apply term_rec with
  (Q := fun n (ts : terms n) => forall u, {ts=u}+{~ts=u}); clear t.
(* var *)
intros. destruct u. case (eq_nat_dec x n); intro. subst n. auto.
right. unfold not. intro. injection H. auto.
right. unfold not. intro. discriminate.
(* fun *)
intros f ts H u. destruct u. right. unfold not. intro. discriminate.
case (eq_symb_dec f f0); intro. subst f0. case (H v); intro. subst ts. auto.
right. unfold not. intro. injection H0. intros. assert (ts=v).
apply (inj_pair2 Sig (fun f => args f)). assumption. auto.
right. unfold not. intro. injection H0. intros. auto.
(* nil *)
intro. VOtac. auto.
(* cons *)
intros. VSntac u. case (H (Vhead u)); intro. rewrite e.
case (H0 (Vtail u)); intro. rewrite e0. auto.
right. unfold not. intro. injection H2. intro. assert (v = Vtail u).
apply (inj_pair2 nat (fun n => terms n)). assumption. auto.
right. unfold not. intro. injection H2. intros. auto.
Qed.

End S.

Implicit Arguments Var [Sig].
Implicit Arguments maxvar_var [Sig k x].
Implicit Arguments maxvar_le_fun [Sig m f ts].
Implicit Arguments maxvar_le_arg [Sig f ts m t].
Implicit Arguments in_varlists [Sig x n ts].
Implicit Arguments varlists_in [Sig x t n ts].
Implicit Arguments varlist_max [Sig x t].

(***********************************************************************)
(** tactics *)

Ltac Funeqtac := repeat
  match goal with
    | H : @Fun ?Sig ?f ?ts = Fun ?f ?us |- _ =>
      let H1 := fresh in let H2 := fresh in
      (injection H; intro H1; assert (H2 : ts = us);
      [apply (inj_pair2 Sig (fun h => @vector (@term Sig) (arity h))); assumption
      | clear H H1])
    | H : @Fun ?Sig ?f ?ts = Fun ?g ?us |- _ =>
      injection H; intros _ fresh; subst g; Funeqtac
  end.
