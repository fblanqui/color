(**
CoLoR, a Coq library on rewriting and termination.
See the COPYRIGHTS and LICENSE files.

- Frederic Blanqui, 2005-06-10

algebraic terms with no arity
*)

(* $Id: VTerm.v,v 1.3 2007-02-01 16:12:24 blanqui Exp $ *)

Set Implicit Arguments.

Require Export LogicUtil.

Section S.

Require Export VSignature.

Variable Sig : Signature.

(***********************************************************************)
(* terms *)

Require Export List.

Inductive term : Set :=
  | Var : variable -> term
  | Fun : forall f : Sig, list term -> term.

(* we delete the induction principle generated by coq since it is not good
because the argument of Fun is a list *)

Reset term_rect.

Notation terms := (list term).

(***********************************************************************)
(** induction principle *)

Section term_rect.

Variables
  (P : term -> Type)
  (Q : terms -> Type).

Hypotheses
  (H1 : forall x, P (Var x))
  (H2 : forall f v, Q v -> P (Fun f v))
  (H3 : Q nil)
  (H4 : forall t v, P t -> Q v -> Q (t :: v)).

Fixpoint term_rect t : P t :=
  match t as t return P t with
    | Var x => H1 x
    | Fun f v => H2 f
      ((fix vt_rect (v : terms) : Q v :=
        match v as v return Q v with
          | nil => H3
          | cons t' v' => H4 (term_rect t') (vt_rect v')
        end) v)
  end.

End term_rect.

Definition term_ind (P : term -> Prop) (Q : terms -> Prop) := term_rect P Q.

Definition term_rec (P : term -> Set) (Q : terms -> Set) := term_rect P Q.

Require Export ListForall.

Lemma term_ind_forall : forall (P : term -> Prop)
  (H1 : forall x, P (Var x))
  (H2 : forall f v, lforall P v -> P (Fun f v)),
  forall t, P t.

Proof.
intros. apply term_ind with (Q := lforall P). assumption. assumption.
exact I. intros. simpl. split; assumption.
Qed.

Lemma term_ind_forall2 : forall (P : term -> Prop)
  (H1 : forall x, P (Var x))
  (H2 : forall f v, (forall t, In t v -> P t) -> P (Fun f v)),
  forall t, P t.

Proof.
intros. apply term_ind with (Q := fun v => forall t, In t v -> P t); simpl.
assumption. assumption. intros. contradiction.
intros. destruct H3. subst. assumption. apply H0. assumption.
Qed.

(***********************************************************************)
(** equality *)

Lemma term_eq : forall f f' v v', f = f' -> v = v' -> Fun f v = Fun f' v'.

Proof.
intros. rewrite H. rewrite H0. refl.
Qed.

Lemma fun_eq : forall f f' v, f = f' -> Fun f v = Fun f' v.

Proof.
intros. rewrite H. refl.
Qed.

Lemma args_eq : forall f v v', v = v' -> Fun f v = Fun f v'.

Proof.
intros. rewrite H. refl.
Qed.

(***********************************************************************)
(** maximal index of a variable *)

Require Export ListMax.

Fixpoint maxvar (t : term) : nat :=
  match t with
    | Var x => x
    | Fun f v =>
      let fix maxvars (v : terms) : nats :=
        match v with
          | nil => nil
          | cons t' v' => cons (maxvar t') (maxvars v')
        end
      in lmax (maxvars v)
  end.

Lemma maxvar_fun : forall f ts, maxvar (Fun f ts) = lmax (map maxvar ts).

Proof.
intros. simpl. apply (f_equal lmax).
induction ts. auto. rewrite IHts. auto.
Qed.

Lemma maxvar_var : forall k x, maxvar (Var x) <= k -> x <= k.

Proof.
intros. simpl. intuition.
Qed.

Definition maxvar_le k t := maxvar t <= k.

End S.

Implicit Arguments Var [Sig].
Implicit Arguments maxvar_var [Sig k x].
